<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Party Animal</title>

    <script src="https://unpkg.com/@rive-app/canvas@2.20.0"></script>
    <!-- zimjs.com - JavaScript Canvas Framework -->
    <script type="module">

        import zim from "https://zimjs.org/cdn/017/zim";

        // See Docs under Frame for FIT, FILL, FULL, and TAG
        new Frame(FIT, 500, 500, "#1ADCEB", black, ready);
        function ready() {

            // create a rive canvas
            const riveCanvas = document.createElement("canvas");
            riveCanvas.setAttribute("width", 500);
            riveCanvas.setAttribute("height", 500);
            document.body.appendChild(riveCanvas);

            // hide the canvas by default
            riveCanvas.style.visibility = "hidden";

            // the trigger for pulling down in rive animation
            let trigger = null;

            // from Rive
            const r = new rive.Rive({
                src: "hedgehog.riv",
                artboard: "Artboard",
                canvas: riveCanvas,
                autoplay: true,
                stateMachines: 'PullAction',
                onLoad: () => {
                    const inputs = r.stateMachineInputs('PullAction');
                    trigger = inputs.find(i => i.name === 'pull');
                }
            });

            const riveCanvasScale = 0.4;
            const riveBitmap = new Bitmap(riveCanvas).sca(riveCanvasScale).center();
            // riveBitmap.pos(10, (W - riveBitmap.height) / 2);
            riveBitmap.on("click", e => {
                trigger.fire();
            });

            const circle = new Circle(10, red).center();

             // for eye rigging
            const maxPupilOffset = 7;

            const leftPupil = new Circle(8, black).center();
            const rightPupil = new Circle(8, black).center();

            const eyeTargetLeft = new Circle(10, red).center().drag();
            const eyeTargetRight = eyeTargetLeft; // Using the same target for both eyes

            // Lerp function for easing
            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            // fast sync at beginning
            let easingFactor = 1;
            let easingRightSide = 0.7; // slow down one eye

            // make eye follow slower and easing after first sync
            timeout(0.1,()=>{
                easingFactor = 0.1;
            })

            Ticker.add(() => {
                if (r && r.artboard) {

                    // Update the HAND_TIP node position
                    const handTip = r.artboard.node("HAND_TIP");
                    if (handTip) {
                        const transform = handTip.worldTransform();
                        const x = transform.tx * riveCanvasScale + riveBitmap.x;
                        const y = transform.ty * riveCanvasScale + riveBitmap.y;
                        circle.x = x;
                        circle.y = y;
                    }

                    // Update the LEFT_PUPIL and RIGHT_PUPIL positions
                    const leftPupilNode = r.artboard.node("LEFT_PUPIL");
                    const rightPupilNode = r.artboard.node("RIGHT_PUPIL");

                    if (leftPupilNode) {
                        const leftEyeTransform = leftPupilNode.worldTransform();
                        const leftEyeCenter = {
                            x: leftEyeTransform.tx * riveCanvasScale + riveBitmap.x,
                            y: leftEyeTransform.ty * riveCanvasScale + riveBitmap.y
                        };

                        const directionLeft = {
                            x: eyeTargetLeft.x - leftEyeCenter.x,
                            y: eyeTargetLeft.y - leftEyeCenter.y
                        };

                        const distanceLeft = Math.hypot(directionLeft.x, directionLeft.y);
                        const normalizedLeft = distanceLeft > 0 ? {
                            x: directionLeft.x / distanceLeft,
                            y: directionLeft.y / distanceLeft
                        } : { x: 0, y: 0 };

                        const offsetLeft = {
                            x: normalizedLeft.x * Math.min(distanceLeft, maxPupilOffset),
                            y: normalizedLeft.y * Math.min(distanceLeft, maxPupilOffset)
                        };

                        // Smoothly follow
                        leftPupil.x = lerp(leftPupil.x, leftEyeCenter.x + offsetLeft.x, easingFactor);
                        leftPupil.y = lerp(leftPupil.y, leftEyeCenter.y + offsetLeft.y, easingFactor);
                    }

                    if (rightPupilNode) {
                        const rightEyeTransform = rightPupilNode.worldTransform();
                        const rightEyeCenter = {
                            x: rightEyeTransform.tx * riveCanvasScale + riveBitmap.x,
                            y: rightEyeTransform.ty * riveCanvasScale + riveBitmap.y
                        };

                        const directionRight = {
                            x: eyeTargetRight.x - rightEyeCenter.x,
                            y: eyeTargetRight.y - rightEyeCenter.y
                        };

                        const distanceRight = Math.hypot(directionRight.x, directionRight.y);
                        const normalizedRight = distanceRight > 0 ? {
                            x: directionRight.x / distanceRight,
                            y: directionRight.y / distanceRight
                        } : { x: 0, y: 0 };

                        const offsetRight = {
                            x: normalizedRight.x * Math.min(distanceRight, maxPupilOffset),
                            y: normalizedRight.y * Math.min(distanceRight, maxPupilOffset)
                        };

                        // Smoothly follow
                        rightPupil.x = lerp(rightPupil.x, rightEyeCenter.x + offsetRight.x, easingFactor*easingRightSide);
                        rightPupil.y = lerp(rightPupil.y, rightEyeCenter.y + offsetRight.y, easingFactor*easingRightSide);
                    }
                }
            });

            Ticker.always();

        } // end ready

    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
</head>

<body></body>

</html>
