<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Party Animal</title>

    <script src="https://unpkg.com/@rive-app/canvas@2.20.0"></script>
    <!-- zimjs.com - JavaScript Canvas Framework -->
    <script type="module">

        import zim from "https://zimjs.org/cdn/017/zim";
        import { BallonRope } from "../js/ballon-rope.js"

        // See Docs under Frame for FIT, FILL, FULL, and TAG
        new Frame(FIT, 500, 500, black, black, ready);
        function ready() {


            // given F (Frame), S (Stage), W (width), H (height)


            // create a rive canvas
            const riveCanvas = document.createElement("canvas");
            riveCanvas.setAttribute("width", 500);
            riveCanvas.setAttribute("height", 500);
            document.body.appendChild(riveCanvas);

            // hide the canvas by default
            riveCanvas.style.visibility = "hidden";

            // the trigger for pulling down in rive animation
            let trigger = null;

            const topRect = new Rectangle({ width: W * 0.8, height: H * 0.8, color: "#A7F5FA", corner: 100 }).center();

            const topTri1 = new Triangle({ a: 360, b: 360, c:320, color: "#8FFAC5" }).center();
            topTri1.y -= 20;

            // insert shader here

            const emitter = new Emitter({
                obj: new Circle(3, [orange, yellow, pink]),
                num: 10,
                gravity: -3.5,
                life: { min: 0.5, max: 0.7 },
            }).center();

            // load rive animation
            const r = new rive.Rive({
                src: "assets/hedgehog.riv",
                artboard: "Artboard",
                canvas: riveCanvas,
                autoplay: true,
                stateMachines: 'PullAction',
                onLoad: () => {
                    const inputs = r.stateMachineInputs('PullAction');
                    trigger = inputs.find(i => i.name === 'pull');
                }
            });

            const riveCanvasScale = 0.35;
            const riveBitmap = new Bitmap(riveCanvas).sca(riveCanvasScale).loc(222, W - riveCanvasScale * 500 - 60);
            riveBitmap.on("click", e => {
                trigger.fire();
            });

            // max pupil offset for eye rigging
            const maxPupilOffset = 25 * riveCanvasScale;

            const pupileSize = 15;
            const leftPupil = new Circle(pupileSize * riveCanvasScale, darker, "#FF0000").center();
            const rightPupil = new Circle(pupileSize * riveCanvasScale, darker, "#FF0000").center();

            const ropeLayer = new Shape(500, 500).center();

            const ballonColor = "#9435D5";

            const ballon = new Label({ text: "FLOATY", size: 100, align: CENTER, font: "verdana", color: red, outlineWidth: 10, outlineColor: red }).reg(CENTER, TOP).center()
            // fake rotation of the text
            ballon.wiggle("rotation", ballon.rotation, 0, 10, 3, 10);
            // using the same target for both eyes
            const eyeTargetLeft = ballon;
            const eyeTargetRight = ballon;

            // Lerp function for easing
            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            // fast sync at beginning
            let easingFactor = 1;
            let easingRightSide = 0.7; // slow down one eye

            // make eye follow slower and easing after first sync
            timeout(0.1, () => {
                easingFactor = 0.1;
            });


            // create the rope and update the start point
            const rope = new BallonRope({
                numParticles: 100,
                segmentLength: 2,
                compliance: 0.001,
                gravity: 0.0005,
                iterations: 5,
                buoyancyForce: 0.1
            });

            let tickCounter = 0; // counter to track the number of ticks
            const maxTicksForDelta = 5;

            Ticker.add((e) => {
                const dt = e.delta;
                if (r && r.artboard) {
                    // update the HAND_TIP node position and do the following rope simulation
                    const handTip = r.artboard.node("HAND_TIP");
                    if (handTip) {
                        const transform = handTip.worldTransform();
                        const x = transform.tx * riveCanvasScale + riveBitmap.x;
                        const y = transform.ty * riveCanvasScale + riveBitmap.y;

                        // start rope follow and simulation
                        const startTip = { x, y }; // New start point for the rope
                        rope.updateStartPoint(startTip, tickCounter < maxTicksForDelta);
                        // apply random impulse for the first few frames
                        if (tickCounter < maxTicksForDelta) {
                            rope.applyImpulse(Math.random(), Math.random());
                        }
                        rope.simulate(dt);
                        const ropePositions = rope.getParticlePositions();

                        // render the rope
                        const ropeColor = black;
                        ropeLayer.c();
                        ropeLayer.s(ropeColor);
                        ropeLayer.mt(ropePositions[0].x, ropePositions[0].y)

                        for (let i = 0; i < ropePositions.length - 1; i++) {
                            const next = (i + 1) % ropePositions.length;
                            ropeLayer.lt(ropePositions[next].x, ropePositions[next].y);
                        }

                        ballon.x = ropePositions[ropePositions.length - 1].x;
                        ballon.y = ropePositions[ropePositions.length - 1].y;

                        emitter.x = ballon.x;
                        emitter.y = ballon.y;

                        tickCounter++;
                    }
                    // Update the LEFT_PUPIL and RIGHT_PUPIL positions
                    const leftPupilNode = r.artboard.node("LEFT_PUPIL");
                    const rightPupilNode = r.artboard.node("RIGHT_PUPIL");

                    if (leftPupilNode) {
                        const leftEyeTransform = leftPupilNode.worldTransform();
                        const leftEyeCenter = {
                            x: leftEyeTransform.tx * riveCanvasScale + riveBitmap.x,
                            y: leftEyeTransform.ty * riveCanvasScale + riveBitmap.y
                        };

                        const directionLeft = {
                            x: eyeTargetLeft.x - leftEyeCenter.x,
                            y: eyeTargetLeft.y - leftEyeCenter.y
                        };

                        const distanceLeft = Math.hypot(directionLeft.x, directionLeft.y);
                        const normalizedLeft = distanceLeft > 0 ? {
                            x: directionLeft.x / distanceLeft,
                            y: directionLeft.y / distanceLeft
                        } : { x: 0, y: 0 };

                        const offsetLeft = {
                            x: normalizedLeft.x * Math.min(distanceLeft, maxPupilOffset),
                            y: normalizedLeft.y * Math.min(distanceLeft, maxPupilOffset)
                        };

                        // Smoothly follow
                        leftPupil.x = lerp(leftPupil.x, leftEyeCenter.x + offsetLeft.x, easingFactor);
                        leftPupil.y = lerp(leftPupil.y, leftEyeCenter.y + offsetLeft.y, easingFactor);

                    }

                    if (rightPupilNode) {
                        const rightEyeTransform = rightPupilNode.worldTransform();
                        const rightEyeCenter = {
                            x: rightEyeTransform.tx * riveCanvasScale + riveBitmap.x,
                            y: rightEyeTransform.ty * riveCanvasScale + riveBitmap.y
                        };

                        const directionRight = {
                            x: eyeTargetRight.x - rightEyeCenter.x,
                            y: eyeTargetRight.y - rightEyeCenter.y
                        };

                        const distanceRight = Math.hypot(directionRight.x, directionRight.y);
                        const normalizedRight = distanceRight > 0 ? {
                            x: directionRight.x / distanceRight,
                            y: directionRight.y / distanceRight
                        } : { x: 0, y: 0 };

                        const offsetRight = {
                            x: normalizedRight.x * Math.min(distanceRight, maxPupilOffset),
                            y: normalizedRight.y * Math.min(distanceRight, maxPupilOffset)
                        };

                        // Smoothly follow
                        rightPupil.x = lerp(rightPupil.x, rightEyeCenter.x + offsetRight.x, easingFactor * easingRightSide);
                        rightPupil.y = lerp(rightPupil.y, rightEyeCenter.y + offsetRight.y, easingFactor * easingRightSide);

                    }
                }

            });

            ballon.on("click", () => { rope.applyImpulse(Math.random() * 50 - 100, Math.random() * 50 - 100); })


        } // end ready

    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
</head>

<body></body>

</html>